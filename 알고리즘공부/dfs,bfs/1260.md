# 백준 1260문제

#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <stdio.h>
 
using namespace std;
 
 

// dfs 스택을 활용함.

void dfs(int start, vector<int>graph[], bool check[]) {
	stack<int> s;
	s.push(start);
	check[start] = true;
	cout << start;
 
	while(!s.empty()) {
		int current_node = s.top();
		s.pop();
		for(int i = 0; i <graph[current_node].size(); i++) {
			int next_node = graph[current_node][i];
			if(check[next_node] == false) {
				cout << " " << next_node;
				check[next_node] = true;
                //앞에서 pop한 현재 node를 다시 넣어주기 위함.
				s.push(current_node);
				s.push(next_node);
				break;
			}
		}
	}
 
 cout << endl;
}
 
 
 
//bfs 큐를 활용함

 void bfs(int start, vector<int> graph[], bool check[]) {
 	queue<int> q;
 	
 	q.push(start);
 	check[start] = true;

 	
 	while(!q.empty()) {
 		int tmp = q.front();
 		q.pop();
 		cout << tmp << " ";
 		for(int i = 0; i < graph[tmp].size();i++) {
 			if(check[graph[tmp][i]] == false) {

 				q.push(graph[tmp][i]);
 				check[graph[tmp][i]] = true;
 			}
 		}
 	}
 	cout << endl;
 }
 
 
 
 
int main() {
	// your code goes here
 ios_base::sync_with_stdio(false);
 cin.tie(NULL);
 cout.tie(NULL);
 
int N,M,V;
 
cin >> N >> M >> V;
 
vector<int> graph[N+1];

bool check[N+1];
// check 값을 false로 초기화해줌
fill(check, check+1+N,false);
 
for(int i = 0; i < M; i++) {
int l1, l2;
	cin >> l1 >> l2;
    
    //그래프를 만듬. 배열이 연결리스트처럼 묶임
	graph[l1].push_back(l2);
	graph[l2].push_back(l1);
}
 
for(int i = 1; i <= N; i++) {
	sort(graph[i].begin(), graph[i].end());
}



 dfs(V,graph,check);
   
   // 다시 초기화를 하지 않으면 오류 발생 
fill(check, check+1+N,false);

bfs(V,graph,check);
 
 
	return 0;
}