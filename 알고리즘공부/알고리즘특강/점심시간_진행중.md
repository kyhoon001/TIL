

```
#include<iostream>
#include<string.h>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
int n, k;
int arr[11][11];
typedef struct {
	int ii, jj;
}people;
typedef struct {
	int ii, jj, cnt;
}stair;
people p [11];
stair st[2];
int pcnt = 0;
int scnt = 0;
int check[11];


void calc(priority_queue<pair<int,int>> pq, int ii, int jj, int stnum) {
    //해결해야 하는것. 123번들 계싼해서 계단 내려가는 시간이랑
    // 계단에 도착 안 했으면 계단까지 가는 시간이랑 계산해서 더 적은걸로
    //빼줘야함. 내려가는 중인 사람을 저장하는 큐를 하나 더 만드는것도 좋을듯
    //밑에 계산한것도 min을 사용해서 계산하면 좋을것같음.
    //전부 다 돌면서 first, second에서 0이면 넘어가고 아니면 min 함수로
    //계속 비교를 해서 값을 찾은 다음에, 그걸 자꾸 빼주는거임.
    // 내일 해볼 예정.


	vector<pair<int,int>> v; // 계단을 내려가는데 걸리는 시간하고, 계단까지 걸리는 시간 넣음.
	v.push_back ({st[stnum].cnt, - pq.top().first }); 
	int tmp = 0;
	int time = 0;
	for (int i = 0; i < sizeof(v); i++) {
		
		if (v[i].second != 0 && tmp <= 3) { // 아직 계단에 도착을 안 했으묜 대기인원이 3명 이하일때
			for (int j = i + 1; j < sizeof(v); j++) { // 첫사람이 도착하는데 걸리는 시간만큼 다 빼줌.
				v[j].second -= v[i].second;// 빼주는 과정
			}
			time += v[i].second; // 걸리는 시간에 추가하고
			v[i].second -= v[i].second; // 계단에 도착했다는 뜻.
			tmp += 1;
		}
		//////////////////////////////////////////////////////여기까지 계단에 도착하는 과정.

		else if (v[i].second == 0 && v[i].first != 0) { // 만약 계단에 도착을 했는데 아직 다 안 내려갔을때.
			if (v[i + 1].second <= v[i].first) { //얘가 내려가는데 걸리는 시간보다 계단까지 가는 시간이 더 짧다면
				for (int j = i + 2; j < sizeof(v); j++) {
					v[j].second -= v[i + 1].second; //뒤쪽 거리에 걸리는 시간 다 빼주고
				}
				time += v[i + 1].second;
				v[i + 1].second -= v[i+1].second;
				v[i].first -= v[i + 1].second;
			}
			else if (v[i + 1].second > v[i].first) { // 만약 i가 내려가는 시간이 i+1이 계단가는 시간보다 짧으면
				for (int j = i + 1; j < sizeof(v); j++) {
					v[j].second -= v[i].first;
					
				}
				time += v[i].first;
				v[i].first -= v[i].first;
				tmp -= 1;
			}


		}
	}

}






void solve(int a,int cnt) { // a는 몇명이 1번 계단으로 가는지를 의미함. cnt는 0부터 시작
	if (cnt == a) {
		////////////////////////////////////////////////요기는 1번 계단 큐
		priority_queue<pair<int,int>> pq; 
		for (int i = 0; i < pcnt; i++) {
			if (check[i] == 1) {
				pq.push({ -(abs(p[i].ii - st[0].ii) + abs(p[i].jj - st[0].jj)) ,i });
			}
		}
		//////////////////////////////////////////////// 1번 계단 큐 끝

		////////////////////////////////////////////////요기는 2번 계단 큐
		priority_queue<pair<int,int>> pq2;
		for (int i = 0; i < pcnt; i++) {
			if (check[i] == 0) {
				pq2.push({ -(abs(p[i].ii - st[1].ii) + abs(p[i].jj - st[1].jj)) ,i });
			}
		}
		//////////////////////////////////////////////// 2번 계단 큐 끝

	}


	for (int i = 0; i < pcnt; i++) {
		if (check[i] == 0) { //아직 방문 안 했다면.
			check[i] = 1;
//			pq.push(p[i]); 이거는 다 cnt 다 끝나면 그 때 넣어주자.
			solve(a, cnt + 1);
			check[i] = 0;


		}
	}




}





int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int t;
	cin >> t;
	for (int tc = 1; tc <= t; tc++) {
		memset(check, 0, 11);
		pcnt = 0;
		scnt = 0;
		cin >> n;
		people ptmp;
		stair stmp;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				cin >> arr[i][j];
				if (arr[i][j] == 1) {
					ptmp.ii = i;
					ptmp.jj = j;
					p[pcnt] = ptmp;
					pcnt++;
				}
				else if (arr[i][j] >= 2) {
					stmp.ii = i;
					stmp.jj = j;
					stmp.cnt = 0;
					st[scnt] = stmp;
					scnt++;
				}
			}
		}


		cout << "#" << tc << " " << answer << endl;// << pq.top() << endl;
		

	}


	return 0;
}
```cpp